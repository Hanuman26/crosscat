/*
*   Copyright (c) 2010-2016, MIT Probabilistic Computing Project
*
*   Licensed under the Apache License, Version 2.0 (the "License");
*   you may not use this file except in compliance with the License.
*   You may obtain a copy of the License at
*
*       http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*   See the License for the specific language governing permissions and
*   limitations under the License.
*/

#include <boost/math/special_functions/bessel.hpp>
#include <cmath>
#include <limits>

#include "numerics.h"
#include "utils.h"

using namespace std;

static double relerr(double expected, double actual) {
    return fabs((expected - actual)/actual);
}

static void test_draw(void) {
    using numerics::draw_sample_unnormalized;
    const double epsilon = std::numeric_limits<double>::epsilon();
    const double denorm_min = std::numeric_limits<double>::denorm_min();

    vector<double> weights;

    weights.resize(4);
    weights[0] = log(1);
    weights[1] = log(2);
    weights[2] = log(4);
    weights[3] = log(8);
    assert(draw_sample_unnormalized(weights, 0.0) == 0);
    assert(draw_sample_unnormalized(weights, 0.1) == 1);
    assert(draw_sample_unnormalized(weights, 0.2) == 2);
    assert(draw_sample_unnormalized(weights, 0.3) == 2);
    assert(draw_sample_unnormalized(weights, 0.4) == 2);
    assert(draw_sample_unnormalized(weights, 0.5) == 3);
    assert(draw_sample_unnormalized(weights, 0.6) == 3);
    assert(draw_sample_unnormalized(weights, 0.7) == 3);
    assert(draw_sample_unnormalized(weights, 0.8) == 3);
    assert(draw_sample_unnormalized(weights, 0.9) == 3);
    assert(draw_sample_unnormalized(weights, 1 - epsilon/2) == 3);

    weights.resize(9);
    weights[0] = -denorm_min;
    for (size_t i = 1; i < weights.size(); i++)
	weights[i] = -1;
    assert(draw_sample_unnormalized(weights, 0) == 0);
    assert(0 <= draw_sample_unnormalized(weights, 1 - epsilon/2));
    assert((size_t)draw_sample_unnormalized(weights, 1 - epsilon/2) <
      weights.size());
}

static void test_linspace(void) {
    vector<double> v;

    v = linspace(42, 43, 2);
    assert(v.size() == 2);
    assert(v[0] == 42);
    assert(v[1] == 43);

    v = linspace(42, 42, 2);
    assert(v.size() == 2);
    assert(v[0] == 42);
    assert(v[1] == 42);

    v = linspace(42, 43, 3);
    assert(v.size() == 3);
    assert(v[0] == 42);
    assert(v[1] == 42.5);
    assert(v[2] == 43);

    v = linspace(42, 42, 3);
    assert(v.size() == 3);
    assert(v[0] == 42);
    assert(v[1] == 42);
    assert(v[2] == 42);

    v = linspace(0, 1, 7);
    assert(v.size() == 7);
    assert(v[6] == 1);
}

static void test_log_linspace(void) {
    vector<double> v;

    v = log_linspace(1, 8, 4);
    assert(v[0] == 1);
    assert(v[1] == 2);
    assert(v[2] == 4);
    assert(v[3] == 8);

    v = log_linspace(0, 42, 4);
    assert(v[0] == std::numeric_limits<double>::min());
    assert(v[3] == 42);

    v = log_linspace(0, 0, 42);
    for (size_t i = 0; i < v.size(); i++)
        assert(v[i] == std::numeric_limits<double>::min());
}

static void test_logaddexp(void) {
    vector<double> v(1);

    v[0] = 1000;
    assert(numerics::logaddexp(v) == 1000);
    v[0] = -1000;
    assert(numerics::logaddexp(v) == -1000);
}

// The values of the modified Bessel function of the first kind with
// nu = 0, 1 tend to overflow outside [-709, +709], depending on the
// exact method used to evaluate it.  So just test a uniform grid of
// values there, generated by the program bessel.cpp.

static void test_bessel(void) {
    static const double i0e[] = {
        1.23154770670165400e+306,
        8.64060224208248464e+299,
        6.06355486411944736e+293,
        4.25603261442151850e+287,
        2.98800266537820785e+281,
        2.09826211076560832e+275,
        1.47382473286544928e+269,
        1.03548598244646494e+263,
        7.27713072718670134e+256,
        5.11563284594497492e+250,
        3.59722733532623695e+244,
        2.53030155402530434e+238,
        1.78040834846892484e+232,
        1.25319176676307875e+226,
        8.82417822255562042e+219,
        6.21582516359315088e+213,
        4.38026942558973507e+207,
        3.08809732255943058e+201,
        2.17811516863629755e+195,
        1.53703266180069692e+189,
        1.08520475645193952e+183,
        7.66623229421532392e+176,
        5.41889743468751645e+170,
        3.83281085940988227e+164,
        2.71282832415018515e+158,
        1.92153869133222393e+152,
        1.36214757916307467e+146,
        9.66444833663966689e+139,
        6.86343433320022117e+133,
        4.87927994849656570e+127,
        3.47267211223380114e+121,
        2.47466453728772990e+115,
        1.76592545379549455e+109,
        1.26212092436926333e+103,
        9.03615804951987665e+96,
        6.48214067380827254e+90,
        4.66039395231502459e+84,
        3.35923482885829892e+78,
        2.42856843027191752e+72,
        1.76188701663370574e+66,
        1.28355264186649118e+60,
        9.39808860168245738e+53,
        6.92426473348450486e+47,
        5.14212824438065119e+41,
        3.85844851766619089e+35,
        2.93654646727135523e+29,
        2.28134342069862139e+23,
        1.83100740013884288e+17,
        1.55990347062181732e+11,
        1.53936747894937813e+05,
        1.00000000000000000e+00,
        1.53936747894920962e+05,
        1.55990347062181732e+11,
        1.83100740013884288e+17,
        2.28134342069862139e+23,
        2.93654646727135523e+29,
        3.85844851766575481e+35,
        5.14212824438065119e+41,
        6.92426473348372115e+47,
        9.39808860168245738e+53,
        1.28355264186649118e+60,
        1.76188701663370574e+66,
        2.42856843027191752e+72,
        3.35923482885829892e+78,
        4.66039395231502459e+84,
        6.48214067380790436e+90,
        9.03615804951987665e+96,
        1.26212092436919171e+103,
        1.76592545379549455e+109,
        2.47466453728758948e+115,
        3.47267211223380114e+121,
        4.87927994849628866e+127,
        6.86343433320022117e+133,
        9.66444833663857112e+139,
        1.36214757916299726e+146,
        1.92153869133222393e+152,
        2.71282832415033880e+158,
        3.83281085940944752e+164,
        5.41889743468720968e+170,
        7.66623229421532392e+176,
        1.08520475645206288e+183,
        1.53703266180060961e+189,
        2.17811516863629755e+195,
        3.08809732255960626e+201,
        4.38026942558923720e+207,
        6.21582516359279686e+213,
        8.82417822255562042e+219,
        1.25319176676322104e+226,
        1.78040834846872269e+232,
        2.53030155402530434e+238,
        3.59722733532623695e+244,
        5.11563284594439370e+250,
        7.27713072718670134e+256,
        1.03548598244646494e+263,
        1.47382473286561674e+269,
        2.09826211076537001e+275,
        2.98800266537820785e+281,
        4.25603261442151850e+287,
        6.06355486411875886e+293,
        8.64060224208150321e+299,
    };
    static const double i1e[] = {
        -1.23067888965247857e+306,
        -8.63438213064202749e+299,
        -6.05909892170071920e+293,
        -4.25283840057319577e+287,
        -2.98571135670705352e+281,
        -2.09661731725642791e+275,
        -1.47264315811858754e+269,
        -1.03463651280285006e+263,
        -7.27101867247115274e+256,
        -5.11123139042528858e+250,
        -3.59405489557111873e+244,
        -2.52801280544068546e+238,
        -1.77875550539537887e+232,
        -1.25199690718446768e+226,
        -8.81553096093478104e+219,
        -6.20955983760586136e+213,
        -4.37572434810839614e+207,
        -3.08479588359686804e+201,
        -2.17571376937298307e+195,
        -1.53528336837751007e+189,
        -1.08392849409101527e+183,
        -7.65690528636694960e+176,
        -5.41206900666695048e+170,
        -3.82780208313026895e+164,
        -2.70914671287504912e+158,
        -1.91882656490666564e+152,
        -1.36014483002938342e+146,
        -9.64962053360065347e+139,
        -6.85242498535870676e+133,
        -4.87108028740881905e+127,
        -3.46654421341918490e+121,
        -2.47006768219344092e+115,
        -1.76246270903799677e+109,
        -1.25950034169699536e+103,
        -9.01622204982702926e+96,
        -6.46688492478025839e+90,
        -4.64864125063932631e+84,
        -3.35011088529169346e+78,
        -2.42142175167506762e+72,
        -1.75623010804411146e+66,
        -1.27901867944677480e+60,
        -9.36119530535991435e+53,
        -6.89367737060279837e+47,
        -5.11616001962349727e+41,
        -3.83570567567467213e+35,
        -2.91576331942750496e+29,
        -2.26114260037075141e+23,
        -1.80935682856467456e+17,
        -1.53215015386715179e+11,
        -1.48405470354675519e+05,
        0.00000000000000000e+00,
        1.48405470354659221e+05,
        1.53215015386715179e+11,
        1.80935682856467456e+17,
        2.26114260037075141e+23,
        2.91576331942750496e+29,
        3.83570567567423900e+35,
        5.11616001962349727e+41,
        6.89367737060201790e+47,
        9.36119530535991435e+53,
        1.27901867944677480e+60,
        1.75623010804411146e+66,
        2.42142175167506762e+72,
        3.35011088529169346e+78,
        4.64864125063932631e+84,
        6.46688492477989202e+90,
        9.01622204982702926e+96,
        1.25950034169692395e+103,
        1.76246270903799677e+109,
        2.47006768219330093e+115,
        3.46654421341918490e+121,
        4.87108028740854201e+127,
        6.85242498535870676e+133,
        9.64962053359955770e+139,
        1.36014483002930623e+146,
        1.91882656490666564e+152,
        2.70914671287520277e+158,
        3.82780208312983420e+164,
        5.41206900666664371e+170,
        7.65690528636694960e+176,
        1.08392849409113840e+183,
        1.53528336837742301e+189,
        2.17571376937298307e+195,
        3.08479588359704317e+201,
        4.37572434810789940e+207,
        6.20955983760550973e+213,
        8.81553096093478104e+219,
        1.25199690718460997e+226,
        1.77875550539517672e+232,
        2.52801280544068546e+238,
        3.59405489557111873e+244,
        5.11123139042470799e+250,
        7.27101867247115274e+256,
        1.03463651280285006e+263,
        1.47264315811875470e+269,
        2.09661731725618990e+275,
        2.98571135670705352e+281,
        4.25283840057319577e+287,
        6.05909892170003070e+293,
        8.63438213064104606e+299,
    };
    const size_t n = 100;
    const double lo = -709;
    const double hi = +709;
    const double w = (hi - lo)/n;
    const double epsilon = std::numeric_limits<double>::epsilon();
    size_t i;

    using numerics::i_0;
    using numerics::i_1;

    for (i = 0; i < n; i++) {
        const double x = lo + i*w;
        assert((i0e[i] == 0 ? i_0(x) == 0 :
            (relerr(i_0(x), i0e[i]) < 10*epsilon)));
        assert((i1e[i] == 0 ? i_1(x) == 0 :
            (relerr(i_1(x), i1e[i]) < 10*epsilon)));
    }
}

int main(int argc, char** argv) {
    test_draw();
    test_linspace();
    test_log_linspace();
    test_logaddexp();
    test_bessel();

    return 0;
}
